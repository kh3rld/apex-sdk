use apex_sdk_substrate::{
    cache::{Cache, CacheConfig},
    metrics::{Metrics, MetricsSnapshot},
    pool::PoolConfig,
    signer::{Ed25519Signer, Sr25519Signer},
    transaction::{BatchMode, FeeConfig, RetryConfig},
    wallet::{KeyPairType, Wallet},
    ChainConfig,
};
use criterion::{black_box, criterion_group, criterion_main, BenchmarkId, Criterion};
use std::sync::Arc;
use std::time::Duration;

// ============================================================================
// Configuration Benchmarks
// ============================================================================

fn benchmark_config_creation(c: &mut Criterion) {
    let mut group = c.benchmark_group("config_creation");

    // Benchmark chain config creation
    group.bench_function("polkadot_config", |b| {
        b.iter(|| black_box(ChainConfig::polkadot()))
    });

    group.bench_function("kusama_config", |b| {
        b.iter(|| black_box(ChainConfig::kusama()))
    });

    group.bench_function("westend_config", |b| {
        b.iter(|| black_box(ChainConfig::westend()))
    });

    // Benchmark pool config creation
    group.bench_function("pool_config", |b| {
        b.iter(|| {
            black_box(PoolConfig::new(vec!["wss://rpc.polkadot.io".to_string()]))
        })
    });

    // Benchmark cache config creation
    group.bench_function("cache_config", |b| {
        b.iter(|| {
            black_box(CacheConfig {
                capacity: 1000,
                ttl_secs: 300,
                enable_storage_cache: true,
                enable_block_cache: true,
            })
        })
    });

    // Benchmark retry config creation
    group.bench_function("retry_config", |b| {
        b.iter(|| {
            black_box(RetryConfig {
                max_retries: 3,
                initial_delay_ms: 100,
                max_delay_ms: 5000,
                backoff_multiplier: 2.0,
            })
        })
    });

    // Benchmark fee config creation
    group.bench_function("fee_config", |b| {
        b.iter(|| {
            black_box(FeeConfig {
                max_fee: Some(1_000_000_000),
                tip: 0,
            })
        })
    });

    group.finish();
}

// ============================================================================
// Cache Benchmarks
// ============================================================================

fn benchmark_cache_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("cache_operations");

    // Create cache with default config
    let config = CacheConfig {
        capacity: 1000,
        ttl_secs: 300,
        enable_storage_cache: true,
        enable_block_cache: true,
    };
    let cache = Cache::new(config);

    // Benchmark cache insertion
    group.bench_function("cache_insert", |b| {
        let mut counter = 0u64;
        b.iter(|| {
            let key = format!("key_{}", counter);
            cache.put_storage(&key, vec![1, 2, 3, 4]);
            counter += 1;
        })
    });

    // Pre-populate cache for lookup benchmarks
    for i in 0..100 {
        cache.put_storage(&format!("preload_{}", i), vec![i as u8; 32]);
    }

    // Benchmark cache hit
    group.bench_function("cache_hit", |b| {
        b.iter(|| {
            black_box(cache.get_storage("preload_50"));
        })
    });

    // Benchmark cache miss
    group.bench_function("cache_miss", |b| {
        b.iter(|| {
            black_box(cache.get_storage("nonexistent_key"));
        })
    });

    // Benchmark cache invalidation
    group.bench_function("cache_invalidate", |b| {
        b.iter(|| {
            cache.invalidate_storage("preload_0");
        })
    });

    // Benchmark cache clear
    group.bench_function("cache_clear", |b| {
        b.iter(|| {
            cache.clear_storage();
        })
    });

    group.finish();
}

fn benchmark_cache_scalability(c: &mut Criterion) {
    let mut group = c.benchmark_group("cache_scalability");

    // Benchmark with different cache sizes
    for size in [100, 1000, 10000].iter() {
        group.bench_with_input(BenchmarkId::new("cache_fill", size), size, |b, &size| {
            b.iter(|| {
                let config = CacheConfig {
                    capacity: size,
                    ttl_secs: 300,
                    enable_storage_cache: true,
                    enable_block_cache: false,
                };
                let cache = Cache::new(config);

                for i in 0..size {
                    cache.put_storage(&format!("key_{}", i), vec![i as u8; 32]);
                }
            })
        });
    }

    // Benchmark lookup performance at different fill levels
    for fill_percent in [50, 75, 90, 100].iter() {
        group.bench_with_input(
            BenchmarkId::new("cache_lookup_at_fill", fill_percent),
            fill_percent,
            |b, &fill_percent| {
                let config = CacheConfig {
                    capacity: 1000,
                    ttl_secs: 300,
                    enable_storage_cache: true,
                    enable_block_cache: false,
                };
                let cache = Cache::new(config);

                // Fill cache to specified percentage
                let fill_count = (1000 * fill_percent) / 100;
                for i in 0..fill_count {
                    cache.put_storage(&format!("key_{}", i), vec![i as u8; 32]);
                }

                b.iter(|| {
                    // Lookup both existing and non-existing keys
                    black_box(cache.get_storage(&format!("key_{}", fill_count / 2)));
                    black_box(cache.get_storage("nonexistent"));
                })
            },
        );
    }

    group.finish();
}

// ============================================================================
// Metrics Benchmarks
// ============================================================================

fn benchmark_metrics_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("metrics_operations");

    let metrics = Arc::new(Metrics::new());

    // Benchmark recording RPC calls
    group.bench_function("record_rpc_call", |b| {
        b.iter(|| {
            metrics.record_rpc_call("test_method");
        })
    });

    // Benchmark incrementing connection count
    group.bench_function("increment_connections", |b| {
        b.iter(|| {
            metrics.increment_active_connections();
        })
    });

    // Benchmark decrementing connection count
    group.bench_function("decrement_connections", |b| {
        b.iter(|| {
            metrics.decrement_active_connections();
        })
    });

    // Benchmark recording cache hits
    group.bench_function("record_cache_hit", |b| {
        b.iter(|| {
            metrics.record_cache_hit();
        })
    });

    // Benchmark recording cache misses
    group.bench_function("record_cache_miss", |b| {
        b.iter(|| {
            metrics.record_cache_miss();
        })
    });

    // Benchmark getting snapshot
    group.bench_function("get_snapshot", |b| {
        b.iter(|| {
            black_box(metrics.snapshot());
        })
    });

    // Benchmark reset
    group.bench_function("reset_metrics", |b| {
        b.iter(|| {
            metrics.reset();
        })
    });

    group.finish();
}

fn benchmark_metrics_concurrent(c: &mut Criterion) {
    let mut group = c.benchmark_group("metrics_concurrent");

    // Benchmark concurrent metric recording
    group.bench_function("concurrent_rpc_recording", |b| {
        let metrics = Arc::new(Metrics::new());
        let runtime = tokio::runtime::Runtime::new().unwrap();

        b.iter(|| {
            runtime.block_on(async {
                let mut tasks = vec![];
                for _ in 0..10 {
                    let metrics_clone = metrics.clone();
                    tasks.push(tokio::spawn(async move {
                        for _ in 0..100 {
                            metrics_clone.record_rpc_call("method");
                        }
                    }));
                }
                for task in tasks {
                    task.await.unwrap();
                }
            });
        })
    });

    group.finish();
}

// ============================================================================
// Wallet and Signer Benchmarks
// ============================================================================

fn benchmark_wallet_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("wallet_operations");

    // Benchmark wallet creation
    group.bench_function("create_sr25519_wallet", |b| {
        b.iter(|| {
            black_box(Wallet::new_random_with_type(KeyPairType::Sr25519));
        })
    });

    group.bench_function("create_ed25519_wallet", |b| {
        b.iter(|| {
            black_box(Wallet::new_random_with_type(KeyPairType::Ed25519));
        })
    });

    // Benchmark wallet from seed
    group.bench_function("wallet_from_seed_sr25519", |b| {
        let mnemonic = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
        b.iter(|| {
            black_box(Wallet::from_mnemonic(mnemonic, KeyPairType::Sr25519));
        })
    });

    group.bench_function("wallet_from_seed_ed25519", |b| {
        let mnemonic = "bottom drive obey lake curtain smoke basket hold race lonely fit walk";
        b.iter(|| {
            black_box(Wallet::from_mnemonic(mnemonic, KeyPairType::Ed25519));
        })
    });

    // Benchmark address derivation
    let wallet = Wallet::new_random_with_type(KeyPairType::Sr25519);
    group.bench_function("derive_address", |b| {
        b.iter(|| {
            black_box(wallet.address());
        })
    });

    group.finish();
}

fn benchmark_signer_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("signer_operations");

    // Create wallets
    let sr25519_wallet = Wallet::new_random_with_type(KeyPairType::Sr25519);
    let ed25519_wallet = Wallet::new_random_with_type(KeyPairType::Ed25519);

    // Note: We can't actually benchmark signing without the underlying crypto,
    // but we can benchmark the wrapper overhead
    group.bench_function("sr25519_wallet_clone", |b| {
        b.iter(|| {
            black_box(sr25519_wallet.clone());
        })
    });

    group.bench_function("ed25519_wallet_clone", |b| {
        b.iter(|| {
            black_box(ed25519_wallet.clone());
        })
    });

    group.finish();
}

// ============================================================================
// Transaction Configuration Benchmarks
// ============================================================================

fn benchmark_transaction_config(c: &mut Criterion) {
    let mut group = c.benchmark_group("transaction_config");

    // Benchmark retry config with backoff calculation
    group.bench_function("retry_backoff_calculation", |b| {
        let config = RetryConfig {
            max_retries: 5,
            initial_delay_ms: 100,
            max_delay_ms: 5000,
            backoff_multiplier: 2.0,
        };

        b.iter(|| {
            for retry in 0..5 {
                let delay = config
                    .initial_delay_ms
                    .saturating_mul((config.backoff_multiplier.powi(retry as i32) as u64))
                    .min(config.max_delay_ms);
                black_box(delay);
            }
        })
    });

    // Benchmark batch mode enum operations
    group.bench_function("batch_mode_comparison", |b| {
        let modes = vec![BatchMode::Serial, BatchMode::Parallel, BatchMode::Atomic];
        b.iter(|| {
            for mode in &modes {
                black_box(mode == &BatchMode::Serial);
                black_box(mode == &BatchMode::Parallel);
            }
        })
    });

    group.finish();
}

// ============================================================================
// Memory and Clone Benchmarks
// ============================================================================

fn benchmark_clone_operations(c: &mut Criterion) {
    let mut group = c.benchmark_group("clone_operations");

    // Benchmark config clones
    let chain_config = ChainConfig::polkadot();
    group.bench_function("clone_chain_config", |b| {
        b.iter(|| black_box(chain_config.clone()))
    });

    let cache_config = CacheConfig {
        capacity: 1000,
        ttl_secs: 300,
        enable_storage_cache: true,
        enable_block_cache: true,
    };
    group.bench_function("clone_cache_config", |b| {
        b.iter(|| black_box(cache_config.clone()))
    });

    let pool_config = PoolConfig::new(vec!["wss://rpc.polkadot.io".to_string()]);
    group.bench_function("clone_pool_config", |b| {
        b.iter(|| black_box(pool_config.clone()))
    });

    // Benchmark wallet clone
    let wallet = Wallet::new_random_with_type(KeyPairType::Sr25519);
    group.bench_function("clone_wallet", |b| {
        b.iter(|| black_box(wallet.clone()))
    });

    group.finish();
}

// ============================================================================
// Serialization Benchmarks
// ============================================================================

fn benchmark_serialization(c: &mut Criterion) {
    let mut group = c.benchmark_group("serialization");

    // Benchmark ChainConfig serialization
    let chain_config = ChainConfig::polkadot();
    group.bench_function("serialize_chain_config", |b| {
        b.iter(|| {
            let json = serde_json::to_string(&serde_json::json!({
                "name": &chain_config.name,
                "endpoint": &chain_config.endpoint,
                "ss58_prefix": chain_config.ss58_prefix,
                "token_symbol": &chain_config.token_symbol,
                "token_decimals": chain_config.token_decimals,
            }))
            .unwrap();
            black_box(json);
        })
    });

    group.finish();
}

criterion_group!(
    benches,
    benchmark_config_creation,
    benchmark_cache_operations,
    benchmark_cache_scalability,
    benchmark_metrics_operations,
    benchmark_metrics_concurrent,
    benchmark_wallet_operations,
    benchmark_signer_operations,
    benchmark_transaction_config,
    benchmark_clone_operations,
    benchmark_serialization,
);

criterion_main!(benches);
